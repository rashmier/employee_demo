# Employee Management REST API

This project is a simple Spring Boot REST API for managing employee records.
<br>This is built as a demo project to show clean backend structure, proper API design, and practical features that are commonly used in real applications.

## Technologies Used

- Java 17
- Spring Boot
- Spring Web (REST API)
- Spring Data JPA (Hibernate)
- MariaDB
- Flyway (database migration)
- Maven
- Docker & Docker Compose
- Swagger / OpenAPI (springdoc)
- Eclipse IDE
- HeideiSQL

## How to Install the Database

- Make sure Docker and Docker Compose are installed on your machine.
- In the project path in demo folder, use command ``docker-compose up -d`` to start database container server
- You can confirm the container is running using command ``docker ps``
- You can manually run a query to create the employee table, simply connect to the database server running in the localhost using the credentials in ``docker-compose.yml file`` and any SQL connectivity application and run the query in ``db/migration/V1__create_employee_table.sql`` manually. I used HeideiSQL. This should Generate the employee table.

## Import the Project in Eclipse

- Open Eclipse IDE
- Go to File → Import
- Select Existing Maven Projects
- Choose the project root directory
- Click Finish
- Wait for Maven to finish updating dependencies

## Running the Application

- Right-click the main Spring Boot application class (DemoApplication.java)
- Choose Run As → Java Application
- You can view application using the URL ``http://localhost:8080/swagger-ui.html``

## Developer Notes

This project was built with the goal of keeping things simple, clean, and practical, while still following good back-end practices.
<br> I used the KISS method and avoided overthinking so that I don't over engineer a simple API, while keeping a good amount of abstraction and separation of responsibilities.

- DTOs are used instead of exposing entities directly. This keeps the API safer and avoids accidentally exposing database details.
- Custom API response format. All endpoints return a consistent response structure with status, message, and data. This makes frontend integration easier.
- No unchecked exceptions in the service layer. Instead of throwing runtime exceptions, the service returns meaningful responses that the controller can pass back to the client.
- PUT and PATCH are separated.
-Email verification endpoint. The /verifyEmail endpoint is designed for frontend form validation when the user leaves the email input field.
- Generic service interface. A reusable CRUD service interface was used so the same structure can be applied to other entities in the future.
- Swagger documentation included. This makes it easier to understand and test the API without extra tools.
- Used Docker for Windows. Ensuring a consistent and isolated database environment, making setup faster and avoiding issues caused by differences in local machine configurations.

## Things to Improve

- Flyway was not working properly but It was not a requirement for the implementation so I skipped debugging it.
- Better handling of ID and EmployeeNo. I used EmployeeNo as the primary key because the requirement for it was to be autogenerated and unique, So I kept things simple and used it as primary key instead of creating a standard employee_id field in the table.
- Better management of the DTO where I showed EmployeeNo in some end-points where It shouldn't be.
- Used proper lombok for getters/setters or boilerplate codes. 

## My Personal Principles as a Developer

I keep things simple and clean, making systems easier to understand and maintain. I code with the intention that my work today will be read by another programmer months or even years after it hits production. Well-documented applications save development time and reduce friction for everyone on the team. I also value consistency and predictability in codebases, as they make collaboration smoother. I thrive in collaborative environments that promote growth, accountability, and long-term stability for everyone involved.
